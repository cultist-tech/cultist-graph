type _Schema_
    @fulltext(
        name: "tokenSearch"
        language: en
        algorithm: rank
        include: [{ entity: "Token", fields: [{ name: "ownerId" }] }]
    )

type Statistic @entity {
    id: ID!

    nftTransferTotal: Int!
    nftPayTotal: Int!
    nftBurnTotal: Int!
    nftTotal: Int!

    marketSaleTotal: Int!
    marketSaleNearFloor: String!
    marketSaleNearSum: String!
    marketSaleNearTotal: Int!

    marketRentTotal: Int!
    marketRentNearFloor: String!
    marketRentNearSum: String!
    marketRentNearTotal: Int!

    accountTotal: Int!
    transactionTotal: Int!
}

type Account @entity {
    id: ID!

    tokens: [Token!]! @derivedFrom(field: "owner")
    marketSales: [MarketSale!]! @derivedFrom(field: "owner")
    marketRents: [MarketRent!]! @derivedFrom(field: "owner")
    ftBalances: [FtBalance!]! @derivedFrom(field: "owner")
}

# nft

type Token @entity {
    id: ID!
    tokenId: String!

    rarity: Int
    bindToOwner: Boolean

    createdAt: Int!
    revealAt: Int

    #

    ownerId: ID!
    tokenMetadataId: ID!
    rentId: ID
    saleId: ID
    fractionationId: ID
    nftIdoId: ID

    owner: Account!
    tokenMetadata: TokenMetadata!
    rent: MarketRent
    sale: MarketSale
    fractionation: NftFractionation
    nftIdo: NftIdo

    royalty: [TokenRoyalty!]! @derivedFrom(field: "token")
}
type TokenMetadata @entity {
    id: ID!
    title: String
    description: String
    media: String

    #

    tokenId: String!
}
type TokenRoyalty @entity {
    id: ID!
    tokenId: ID!
    accountId: String!
    value: Int!

    token: Token!
}

# rent

type MarketRent @entity {
    id: ID!
    contractId: ID!
    tokenId: ID!
    ownerId: ID!

    minTime: Int!
    maxTime: Int!
    endedAt: Int
    createdAt: Int!
    renterId: ID

    owner: Account!
    token: Token!
    conditions: [MarketRentCondition!]! @derivedFrom(field: "rent")
}
type MarketRentCondition @entity {
    id: ID!
    ftTokenId: ID!
    price: String!

    rent: MarketRent!
    rentId: ID!
}

# market

type MarketSale @entity {
    id: ID!
    ownerId: ID!
    contractId: ID!
    tokenId: ID!

    isAuction: Boolean!
    createdAt: Int!

    owner: Account!
    token: Token!
    conditions: [MarketSaleCondition!]! @derivedFrom(field: "sale")
}
type MarketSaleCondition @entity {
    id: ID!
    ftTokenId: ID!
    price: String!

    sale: MarketSale!
    saleId: ID!
}

# ft

type FtBalance @entity {
    id: ID!
    contractId: ID!
    accountId: ID!

    balance: BigInt!
    owner: Account!
}

# nft-ido

type NftIdo @entity {
    id: ID!

    idoId: ID!
    contractId: ID!

    name: String!
    media: String
    amount: Int
    price: String!
    buyMax: Int!
    perTransactionMin: Int!
    perTransactionMax: Int!

    amountReady: Int!
    notMinted: Int!
    locked: Boolean!
    startDate: Int
    ftToken: String

    tokens: [Token!]! @derivedFrom(field: "nftIdo")
}

# nft-fractionation

type NftFractionation @entity {
    id: ID!

    contractId: ID!
    tokenId: ID!

    createdAt: Int!
    competedAt: Int
    competedBy: ID

    token: Token!
    tokens: [Token!]! @derivedFrom(field: "fractionation")
}
